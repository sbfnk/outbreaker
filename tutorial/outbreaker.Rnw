\documentclass{article}
%\VignettePackage{outbreaker}
%\VignetteIndexEntry{Handling disease outbreak data}
%\VignetteEngine{knitr}

\usepackage{graphicx}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage{color}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}

\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\newcommand{\code}[1]{{{\tt #1}}}
\title{An introduction to \textit{outbreaker} \Sexpr{packageDescription("outbreaker", fields = "Version")}}
\author{Thibaut Jombart}
\date{\today}




\sloppy
\hyphenpenalty 10000


\begin{document}


<<eval=TRUE,echo=FALSE,results='hide'>>=
library(knitr)
opts_chunk$set(fig.path='figs/', fig.keep='high', dev='pdf', fig.width=7, fig.height=7,
               tidy=FALSE, warning=FALSE, fig.show='asis', fig.align='center', cache=FALSE,
               out.width=".6\\textwidth")
options(width=80)
@

\color{black}

\maketitle

\begin{abstract}
  This vignette introduces the main functionalities of \textit{outbreaker} \cite{outbreaker}, a
  package implementing a model for disease outbreak reconstruction using epidemiological data and
  pathogen genome sequences. The emphasis of this document is put on using \textit{outbreaker} and
  on the visualization and interpretation of results.
  \\

  More resources for disease outbreaks analysis in R are available on the \textit{R-epi project}:
  \url{http://sites.google.com/site/therepiproject}. Questions about \textit{outbreaker}, alonside
  any question relating to the analysis of epidemics, should be asked on the R-epi forum. To do so, send an
  email to: \url{r-epi@googlegroups.com}, or visit the website:
  \url{http://groups.google.com/forum/#!forum/r-epi}.
\end{abstract}


\tableofcontents
\newpage





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running outbreaker}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A simple example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this vignette, we shall use the toy dataset \texttt{fakeOutbreak} distributed with \textit{outbreaker}.
We first load the package, the dataset, and look at the object's content:
<<>>=
library(outbreaker)
data(fakeOutbreak)
class(fakeOutbreak)
names(fakeOutbreak)
class(fakeOutbreak$dat)
fakeOutbreak$w
fakeOutbreak$collecDates
@


\texttt{fakeOutbreak} is a list containing \texttt{dat}, a simulated outbreak (obtained by
\texttt{simOutbreak}), a generation time distribution (\texttt{w}), collection dates for the DNA
sequences (\texttt{collecDates}), and results from \textit{outbreaker} (\texttt{res}).
We shall need only the first 3 items, and re-create the fourth.
<<>>=
dat <- fakeOutbreak$dat
w <- fakeOutbreak$w
collecDates <- fakeOutbreak$collecDates
plot(dat, main="Simulated outbreak")
barplot(w, main="Generation time distribution", ylab="probability", xlab="days", names=0:3)
@


We run \textit{outbreaker} on these data, using the parallel version, and specifying that we want
to run 4 MCMC in parallel and 100,000 chains for each MCMC.
<<eval=FALSE>>=
set.seed(1)
res <-  outbreaker.parallel(n.runs=4, dna=dat$dna,
                            dates=collecDates,w.dens=w, n.iter=1e5)
@
<<echo=FALSE,eval=TRUE>>=
load("objects/res.RData")
@

<<>>=
names(res)
@

<<>>=
names(res$chains)
@


<<>>=
class(res)
names(res)
@
The object \texttt{res} is a list with a number of named items, described in \texttt{?outbreaker}.
The most important one is \texttt{res\$chains}, containing the MCMC outputs:
<<>>=
class(res$chains)
dim(res$chains)
names(res$chains)
res$chains[1:10,1:10]
@
The columns of this \texttt{data.frame} store the following outputs:
\begin{itemize}
  \item \texttt{step}: the MCMC iteration of the sample
  \item \texttt{post/like/prior}: log values for posterior, likelihood, and prior densities
  \item \texttt{mu1}: in mutation model 1, mutation rate; otherwise, the rate of transitions, per site and generation
  \item \texttt{mu2}: in mutation model 1, mutation rate (mu1=mu2); otherwise, the rate of transversions, per site and generation
  \item \texttt{gamma}: the ratio between transversions and transitions ($\mu_2 / \mu_1$)
  \item \texttt{pi}: the proportion of the transmission tree sampled
  \item \texttt{Tinf\_[}\textit{number}\texttt{]}: dates of infection
  \item \texttt{alpha\_[}\textit{number}\texttt{]}: the index of the ancestral cases (infectors)
  \item \texttt{kappa\_[}\textit{number}\texttt{]}: the number of generations between cases and
    their most recent sampled ancestor (here, fixed to 1)
  \item \texttt{run}: for parallel runs, the index of the run.
\end{itemize}

We shall see how this information can be used, visualized and interpreted over the following sections.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Assessing convergence and determining the burnin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A MCMC is said to converge when it reaches a stationary state, i.e. its distributional properties are
constant over time (mean and variance don't depend on which window of the MCMC you consider).
Convergence of the chains is best assessed by comparing parallel runs.
This can be done using \texttt{plotChains}, which we to visualize the trace of the log-posterior
values of the model:
<<>>=
plotChains(res, main="Trace of log-posterior values")
@

\noindent We set the burnin to a conservative 20,000 steps, and plot the MCMC output as trace and as densities:
<<>>=
plotChains(res, main="Trace of log-posterior values \n(burnin removed)",
           burnin=2e4)
plotChains(res, main="Density log-posterior values \n(burnin removed)",
           burnin=2e4, type="dens")
@
Here, all four runs have sampled from the same distribution, confirming convergence of the MCMCs.
Note that this can also be tested using a simple ANOVA, which we use to check that log-posterior
values do no differ from one run to another:
<<>>=
anova(lm(post~run, data=res$chains[res$chains$step>2e4,]))
@


These graphs can be slightly improved by using \textit{ggplot2} \cite{ggplot2}.
We first load the package, and make sure that \texttt{run} is treated as a \texttt{factor}:
<<>>=
library(ggplot2)
library(reshape2)
library(mgcv)
x <- res$chains
x$run <- factor(x$run)
@
The basic plot of the log-posterior trace is obtained by:
<<>>=
p <- ggplot(x, aes(x=step)) +
    geom_line(aes(y=post, colour=run)) +
    labs(title="Trace of log-posterior", y="log-posterior")
p
@

The version without the burnin is:
<<>>=
p <- ggplot(x[x$step>2e4,], aes(x=step)) +
    geom_line(aes(y=post, colour=run)) +
    labs(title="Trace of log-posterior", y="log-posterior")
p
@

A model of the mean can be added easily:
<<>>=
p + geom_smooth(aes(y=post))
@

\textit{ggplot2} is also pretty good for plotting distributions.
Here is an example using 1-dimensional density estimation:
<<>>=
p <- ggplot(data=x) + labs(title="Distribution of log-posterior values", x="log-posterior") +
    scale_x_continuous(limits=c(-460,-430))
p + geom_density(aes(x=post, fill=run), alpha=.3, colour=NA) +
    geom_density(aes(x=post), size=1, colour="black", shape=2, alpha=.8)

@
and another version using histograms:
<<>>=
p + geom_histogram(aes(x=post, fill=run, y=..density..), alpha=.7, colour=NA, position="dodge") +
    geom_density(aes(x=post), size=1, colour="black", shape=2, alpha=.8)

@






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interpreting the results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textit{outbreaker} can provide information on:
\begin{itemize}
  \item the transmission tree (``who infected whom''); ancestry for case $i$ is noted $\alpha_i$
  \item the dates of infection; for case $i$, noted $T^{inf}_i$
  \item the mutation rate per generation of infection ($\mu$)
  \item the proportion of the outbreak sampled ($\pi$)
  \item effective reproduction numbers over time or at an individual level $^\dagger$
  \item incidence curves $^\dagger$
  \item the mutation rate per unit of time $^\dagger$
\end{itemize}
Items indicated with a $^\dagger$ are not explicitely modelled by \textit{outbreaker}, but can be derived from the
posterior samples of trees and parameters.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visualizing reconstructed transmission trees}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textit{outbreaker} being a Bayesian approach, it does not return a single tree, but a distribution
of plausible transmission trees.
A set of ancestries can be visualized by \texttt{transGraph}
<<>>=
library(igraph)
library(adegenet)
@
<<>>=
g <- transGraph(res, thres=0)
@
Annotations represent the number of mutations for the ancestries, and their support (frequency in
the posterior samples).
Note that this function returns an \textit{igraph} object, which can be used for further plotting
and customization:
<<>>=
g
plot(g, layout=layout.circle, edge.curved=FALSE, vertex.color=funky(30))
@
see \texttt{?plot.igraph} and \texttt{igraph.plotting} for more information on how to customize
these graphics.
We illustrate some possibilities below:
<<>>=
g <- transGraph(res, thres=0.5, annot="")
edge.colors <- funky(30)[as.numeric(get.edgelist(g)[,1])]
plot(g, layout=layout.circle, edge.curved=FALSE, vertex.color=funky(30),
     edge.color=edge.colors)
title("Ancestries with support >50% - circular graph")

plot(g, layout=layout.auto, edge.curved=FALSE, vertex.color=funky(30),
     edge.color=edge.colors)
title("Ancestries with support >50% - other layout")
@

Here we ensure that cases with higher reproduction numbers look bigger:
<<>>=
case.size <- 10+apply(get.R(res),2,mean)*5
plot(g, layout=layout.auto, edge.curved=FALSE, vertex.color=funky(30),
     edge.color=edge.colors, vertex.size=case.size)
title("Ancestries with support >50% \n(node size reflects R)")
@
Same idea, but this time colors represent dates of infection:
<<>>=
Tinf <- x[x$step>=2e4,grep("Tinf", names(x))]
case.color <- any2col(apply(Tinf,2,mean), col.pal=spectral)
plot(g, layout=layout.auto, edge.curved=FALSE, vertex.color=case.color$col,
     vertex.size=case.size)
title("Ancestries with support >50% \n(node size reflects R)")
legend("bottomleft", col=case.color$leg.col, leg=case.color$leg.txt,
       title="Mean infection date", pch=20, pt.cex=3, inset=-.1)
@

The same can be done with a tree formed by consensus ancestries, obtained by \texttt{get.tTree}:
<<>>=
plot(get.tTree(res), main="Consensus ancestries - basic plot")
@

For a customized version where colors represent the mean infection dates:
<<>>=
tre <- get.tTree(res)
plot(tre, edge.curved=TRUE, vertex.color=case.color$col,
     vertex.size=case.size)
title("Consensus ancestries \n(x-axis represents time)")
legend("bottomleft", col=case.color$leg.col, leg=case.color$leg.txt,
       title="Mean infection date", pch=20, pt.cex=3, inset=-.1)
@
and another, without the time axis:
<<>>=
g <- as.igraph(get.tTree(res))
plot(g, edge.curved=FALSE, vertex.color=case.color$col, layout=layout.auto,
     vertex.size=case.size, edge.label="")
title("Consensus ancestries")
legend("bottomleft", col=case.color$leg.col, leg=case.color$leg.txt,
       title="Mean infection date", pch=20, pt.cex=3, inset=-.1)
@
Note that all these plots can be visualized interactively using \texttt{tkplot} (just replace
\texttt{plot} with \texttt{tkplot} in the above command lines).
In all these graphs, we can see that cases 1, 4 and 28 have been classified as imported cases.
For a more systematic assessment of imported cases, we can just look for cases for which the
ancestor is unknown (NA) in the consensus tree:
<<>>=
temp <- get.tTree(res)
temp$ances
which(is.na(temp$ances))
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Plotting dates of infection}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Dates of infection are stored in the table of MCMC outputs, with columns starting with \texttt{Tinf}:
<<>>=
Tinf <- x[x$step>=2e4,c(1,ncol(x),grep("Tinf", names(x)))]
Tinf[1:5,1:6]
@
This information can be visualized easily using the basic \texttt{boxplot}:
<<>>=
boxplot(Tinf[,-c(1,2)], horizontal=TRUE, las=1, xlab="Date",
        main="Distribution of infection dates", col=funky(30))
@
We can also use \textit{ggplot2}, but this demands a slight reformating of the data:
<<>>=
Tinf <- melt(Tinf, id=1:2)
names(Tinf)[3:4] <- c("case", "date")
Tinf$case <- sub("Tinf_","Case ", Tinf$case)
Tinf$case <- factor(Tinf$case, levels=paste("Case",1:30))
head(Tinf)
tail(Tinf)
@

In this case, little is gained in the new plot:
<<>>=
p <- ggplot(data=Tinf) + geom_boxplot(aes(x=case,y=date,fill=case), alpha=.5) +
   coord_flip() + labs(y="Infection date", x="", title="Distribution of infection dates")
p + guides(fill=FALSE)
@

However, it would be simple to compare infection dates of different runs, which may be useful if
different runs provide slightly different results:
<<>>=
ggplot(data=Tinf) + geom_boxplot(aes(x=case,y=date,fill=run),alpha=.5) + coord_flip() +
    labs(y="Infection date", x="", title="Distribution of infection dates")
@




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Accessing posterior distributions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Any element of the model in \texttt{res\$chains} can be plotted using \texttt{plotChains}: it just
needs to be named in the argument \texttt{what}.
For instance, the mutation rate:
<<>>=
plotChains(res, main="Trace of mu \n(burnin removed)",
           burnin=2e4, what="mu1")
plotChains(res, main="Trace of mu \n(burnin removed)",
           burnin=2e4, what="mu1", type="dens")
@
(note that in this case, the plotted information is the mutation rate \textit{per generation of
  infection}, and not per unit of time.
See section on mutation rates below for an estimation of the rates per unit of time.
\\

To derive statistics for a given distribution, one just needs to extract the relevant column, making
sure to remove the burnin:
<<>>=
mu <- res$chains$mu1[res$chains$step>2e4]
head(mu)
length(mu)
head(mu)
summary(mu)
@
Here we have \Sexpr{length(mu)} values to estimate parameters of the distribution of $mu$.
However, the effective sample size might be smaller if successive values are correlated
(autocorrelated chains).
This can be tested easily:
<<>>=
cor(mu[-length(mu)], mu[2:length(mu)])
cor.test(mu[-length(mu)], mu[2:length(mu)])
@
No, there is no correlation between successive values.
\\



As before, \texttt{ggplot2} versions of the plot can be obtained; here, for the parameter $\pi$
(proportion of the outbreak sampled):
<<>>=
library(ggplot2)
library(reshape2)
x <- res$chains[x$step>2e4,]
x$run <- factor(x$run)
@
To plot densities:
<<>>=
p <- ggplot(data=x) + labs(title="Posterior distribution of pi", x="Pi (proportion of cases sampled)")
p + geom_density(aes(x=pi, fill=run), alpha=.3, colour=NA) +
    geom_density(aes(x=pi), size=1, colour="black", shape=2, alpha=.8)
@
Histograms:
<<>>=
p + geom_histogram(aes(x=pi, fill=run, y=..density..), alpha=.7, colour=NA, position="dodge") +
    geom_density(aes(x=pi), size=1, colour="black", shape=2, alpha=.8)
@
Using different boxplots for different runs:
<<>>=
p + geom_boxplot(aes(x=run, y=pi, fill=run),alpha=.6) +
    geom_jitter(aes(x=run, y=pi, col=run),alpha=.4)
@
Same idea, but using violinplots:
<<>>=
p + geom_violin(aes(x=run, y=pi, fill=run),alpha=.6)
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mutation rates}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
As mentioned before, mutation rates in \textit{outbreaker}'s model are expressed per generation of infection.
However, mutation rates per unit of time are biologically easier to interpret.
These can be obtained using \texttt{get.mu}:
<<>>=
mu <- get.mu(res, burnin=2e4)
summary(mu)
hist(mu, col="grey",border="lightgrey", xlab="Mutation rate (per genome and unit time)",
     main="Posterior distribution of mu")
@

Re-expressing the rates per nucleotide, and adding the media and 95\%credibility interval to the histogram:
<<>>=
mu <- get.mu(res, burnin=2e4, genome.size=ncol(dat$dna))
summary(mu)
hist(mu, col="grey",border="lightgrey", xlab="Mutation rate (per genome and unit time)",
     main="Posterior distribution of mu")
abline(v=quantile(mu, c(.025, .5, .975)), lty=c(2,1,2), lwd=2, col="royalblue")
legend("topright", lty=c(1,2), leg=c("Median","95% credibility interval"),
       col="royalblue", bg="white")
@

Same idea, using a one-dimensional density estimation:
<<>>=
plot(density(mu), xlab="Mutation rate (per genome and unit time)",
     main="Posterior distribution of mu", lwd=3)
points(jitter(mu), rep(0, length(mu)), pch="|", col=transp("blue"))
abline(v=quantile(mu, c(.025, .5, .975)), lty=c(2,1,2), lwd=2, col="royalblue")
legend("topright", lty=c(1,2), leg=c("Median","95% credibility interval"),
       col="royalblue", bg="white")
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Incidence and reproduction numbers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Incidence curves and effective reproduction numbers can be derived from the results of \textit{outbreaker}.
Incidence curves can be obtained and visualized using \texttt{get.incid}:
<<>>=
incid <- get.incid(res, burnin=2e4)
class(incid)
dim(incid)
incid[,1:10]
@
Each column in \texttt{incid} is a different realization of an incidence curve corresponding to one
step of the MCMC.
Other graphical options are available:
<<>>=
args(get.incid)
incid <- get.incid(res, type="lines",lines.col=transp("black",.1))
title("Posterior estimates of incidence")
@
Because a lot of these trajectories overlap, visualizing them all is a bit tricky.
\textit{ggplot2} will be helpful here.
We first reformat the data:
<<>>=
x <- data.frame(date=as.vector(row(incid)),
                step=as.vector(col(incid)),
                incidence=as.vector(incid))
head(x)
p <- ggplot(data=x, aes(x=date, y=incidence)) + labs(title="Posterior estimates of incidence")
@

This is for a basic boxplot:
<<>>=
p + geom_boxplot(aes(x=factor(date)))
@
<<>>=
p + geom_boxplot(aes(x=factor(date)))
@
A noisified version with a smoother can be obtained using:
<<>>=
library(splines)
p + geom_jitter(aes(x=factor(date)), alpha=.2) + geom_smooth(method=lm, formula=y~ns(x,10), size=1)
@
However, it adds artifactual variation and may be best avoided here.

Another interesting option is offered by some density-based graphics:
<<>>=
p + geom_bin2d() + geom_smooth(method=lm, formula=y~ns(x,10), size=1)
@
or perhaps even better:
<<>>=
p + geom_hex(bins=8, alpha=.5) + geom_smooth(colour="purple4",size=2)
@



Effective reproduction numbers over time can be obtained using \texttt{get.Rt}, and given identical outputs to \texttt{get.incid}.
Effective reproduction numbers per individuals can be obtained by \texttt{get.R}:
<<>>=
R <- get.R(res)
class(R)
dim(R)
R[1:6,1:15]
@
\texttt{R} is a matrix of effective reproduction numbers with one column per individual and one row
for each retained step of the MCMC.
This information can be pooled to get a rough idea of the overall distribution of $R_i$:
<<>>=
table(R)
table(R)/length(R)
barplot(table(R)/length(R), xlab="Number of secondary cases",
        main="Posterior estimates of effective reproduction numbers (R)", ylab="Frequency")
@
And we can use \textit{ggplot2} to visualize the individual distributions:
<<>>=
x <- data.frame(case=factor(as.vector(col(R)), levels=as.character(1:30)),R=as.vector(R))
head(x)
tail(x)

p <- ggplot(data=x, aes(x=case, y=R)) + geom_boxplot(aes(colour=case))
p <- p + geom_boxplot(aes(colour=case)) + guides(colour=FALSE)
p + labs(title="Posterior estimates of effective reproduction numbers")
@





%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \section{Advanced uses}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \subsection{Fixing known ancestries}
%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage
\bibliographystyle{plain}
\bibliography{outbreaker}



\end{document}
